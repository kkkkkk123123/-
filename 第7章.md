练习
==
7.1-1
--
	参考图7-1 易得
7.1-2
--
	返回r
	PARTITION(A,p,r):
	x=A[r]
	i=p-1
	for j=p to r-1
		if A[j]<=A[x]
			i=i+1
			exchange A[i] with A[j]
	if (i+1)=r
		return (p+r)/2
	exchange A[i+1] with A[r]
	return i+1
7.1-3
--
	再循环中PARTITION会遍历数组，其余为常数时间，总共为cn，所以时间复杂度为Θ(n)
7.1-4
--
	伪码如下,只要修改PARTITION就可以
	QUICKSORT(A,p,r):
	if p<r
		q=PARTITON(A,p,r)
		QUICKSORT(A,p,q-1)
		QUICKSORT(A,q+1,r)
	-----
	DE-PARTITON（A,p,r):
	x=A[r]
	i=p-1
	for j=p to r-1
		if A[j]>A[x]
			i=i+1
			exchange A[i] with A[j]
	if (i+1)=r
		return (p+r)/2
	exchange A[i+1] with A[r]
	return i+1
7.2-1
--
	假设T(n)<=cn^2
	T(n)=T(n-1)+bn
	   <=c(n-1)^2+Θ(n)=cn^2-2cn+c+bn<cn^2(当b<2c时）
7.2-2
--
	Θ(n^2)这是最差情况每次都是（n-1)和1分割，产生空分区
7.2-3
--
	无论是升序还是降序都是最差情况
	每次分割都是将n-1个元素分在一侧，产生空的分区，形成T(n)=T(n-1)+Θ(n)递归式
7.2-4
--
	显然是插入排序快，插入排序常数项小，数组越小越有优势
	因为插入排序的总时间为Θ(n+m)其中m时逆序对数量，一个已经排好序的数组逆序对很少
	所以插入排序时间很接近Θ(n)
	而快速排序对有序数组排序较慢，很可能产生空分区
7.2-5
--
	最小深度方程为n/a^x<=1 对其求解x=-（lgn/lga)
	最大深度方程为n/(1-a)^x<=1 对其求解x=-（lgn/lg(1-a))
7.2-6
--
